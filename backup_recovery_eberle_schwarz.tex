\documentclass[11pt,a4paper,parskip=half]{scrartcl}
\usepackage{ngerman}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks=false,pdfborder={0 0 0}]{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{longtable}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{nameref}
\geometry{a4paper, left=30mm, right=25mm, top=30mm, bottom=35mm} 
\usepackage{listings}
\lstset{breaklines=true, breakatwhitespace=true, basicstyle=\tiny, numbers=left, frame=single}
\setcounter{tocdepth}{2} %no subsubsections in TOC

\title{dbarc: Ausarbeitung Backup \& Recovery}
\author{Yanick Eberle, Pascal Schwarz}
\begin{document}
\maketitle
\vfill
\tableofcontents

\pagestyle{fancy}
\section{Vorbereitung}
\subsection{Kontrolle Dateien}
Die genannten Files liegen bei uns im korrekten Pfad:
\begin{lstlisting}
oracle_stud@hades:/> ls /app/oracle_stud/oradata/${ORACLE_SID}/data/
control01.ctl  control02.ctl  control03.ctl  redo01.log  redo02.log  redo03.log  sysaux01.dbf  system01.dbf  temp01.dbf  undotbs01.dbf  users01.dbf
\end{lstlisting}

\subsection{Noarchivelog Modus}
Wir wechseln gemäss den Angaben in der Aufgabenstellung den Modus unserer Oracle-Instanz:
\begin{lstlisting}
oracle_stud@hades:/> sqlplus sys as sysdba

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 07:02:06 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Enter password: 
Connected to an idle instance.

SQL> STARTUP MOUNT
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size		    2213936 bytes
Variable Size		  339740624 bytes
Database Buffers	   67108864 bytes
Redo Buffers		    8482816 bytes
Database mounted.

SQL> ALTER DATABASE NOARCHIVELOG;
Database altered.

SQL> ALTER DATABASE OPEN;
Database altered.
\end{lstlisting}

\subsection{System entlasten}
Bei unserer Instanz liegen die Trace-Files im angegebenen Verzeichnis in einem Unterordner \emph{trace}. Wie die Ausgabe von \emph{find ... | wc -l} zeigt, ist eine grosse Zahl dieser Dateien vorhanden:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/diag/rdbms/dbarc02/dbarc02/trace> find -iname '*.trc' | wc -l
3787
oracle_stud@hades:/app/oracle_stud/diag/rdbms/dbarc02/dbarc02/trace> rm *.trc

\end{lstlisting}

Unser Alert-Log ist mit ca. 100k noch recht kompakt, wir leeren es trotzdem.
\begin{lstlisting}
oracle_stud@hades:...dbarc02/trace> ls -lh alert_dbarc02.log 
-rw-r----- 1 oracle_stud oinstall 103K 2013-06-21 07:08 alert_dbarc02.log
oracle_stud@hades:...dbarc02/dbarc02/trace> echo -n "" > alert_dbarc02.log 
oracle_stud@hades:...dbarc02/trace> ls -lh alert_dbarc02.log 
-rw-r----- 1 oracle_stud oinstall 0 2013-06-21 07:17 alert_dbarc02.log
\end{lstlisting}

Wie der folgende Befehl zeigt, existiert auf dem Server Hades nirgends ein Verzeichnis \emph{bdump}:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/admin/dbarc02> find / -type d -iname 'bdump' 2>/dev/null 
oracle_stud@hades:/app/oracle_stud/admin/dbarc02>
\end{lstlisting}


\section{Export / Import einer Tabelle}
\subsection{Export}
Nach der Anmeldung führen wir gemäss Aufgabenstellung den Export-Befehl im entsprechenden Verzeichnis aus und überprüfen mittels ls, dass die Files erzeugt wurden (da der Datenbank-Name mit unserer SID übereinstimmt, verwenden wir gleich diese exportierte Variable):
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> exp scott/tiger FILE=${ORACLE_SID} LOG=${ORACLE_SID}

Export: Release 11.2.0.1.0 - Production on Fri Jun 21 07:23:10 2013

Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.


Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
Export done in US7ASCII character set and AL16UTF16 NCHAR character set
server uses AL32UTF8 character set (possible charset conversion)
. exporting pre-schema procedural objects and actions
. exporting foreign function library names for user SCOTT 
. exporting PUBLIC type synonyms
. exporting private type synonyms
. exporting object type definitions for user SCOTT 
About to export SCOTT's objects ...
. exporting database links
. exporting sequence numbers
. exporting cluster definitions
. about to export SCOTT's tables via Conventional Path ...
. . exporting table                           DEPT          4 rows exported
EXP-00091: Exporting questionable statistics.
EXP-00091: Exporting questionable statistics.
. . exporting table                            EMP         14 rows exported
EXP-00091: Exporting questionable statistics.
EXP-00091: Exporting questionable statistics.
. . exporting table                       SALGRADE          5 rows exported
EXP-00091: Exporting questionable statistics.
. exporting synonyms
. exporting views
. exporting stored procedures
. exporting operators
. exporting referential integrity constraints
. exporting triggers
. exporting indextypes
. exporting bitmap, functional and extensible indexes
. exporting posttables actions
. exporting materialized views
. exporting snapshot logs
. exporting job queues
. exporting refresh groups and children
. exporting dimensions
. exporting post-schema procedural objects and actions
. exporting statistics
Export terminated successfully with warnings.


oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> ls -lh
total 28K
-rw-r--r-- 1 oracle_stud oinstall  24K 2013-06-21 07:23 dbarc02.dmp
-rw-r--r-- 1 oracle_stud oinstall 1.7K 2013-06-21 07:23 dbarc02.log
\end{lstlisting}

\subsection{Tabelle löschen}
Das folgende Listing zeigt das Löschen der \emph{emp}-Tabelle.

\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> sqlplus scott/tiger

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 07:30:04 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> DESC emp;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 EMPNO					   NOT NULL NUMBER(4)
 ENAME						    VARCHAR2(10)
 JOB						    VARCHAR2(9)
 MGR						    NUMBER(4)
 HIREDATE					    DATE
 SAL						    NUMBER(7,2)
 COMM						    NUMBER(7,2)
 DEPTNO 					    NUMBER(2)

SQL> DROP TABLE emp;
Table dropped.

SQL> DESC emp;
ERROR:
ORA-04043: object emp does not exist
\end{lstlisting}

\subsection{Tabelle zurückladen}
Wir führen den Import-Befehl wiederum gemäss Aufgabenstellung aus. Bei der ersten Frage (\glqq{}Import Data Only?\grqq{}), deren Antwort nicht in der Aufgabe vorgegeben ist, haben wir mit \glqq{}Yes\grqq{} geantwortet. 

Die Beantwortung mit \glqq{}No\grqq{} führt dazu, dass der Import-Befehl die Tabelle nicht erstellt und legiglich versucht, Datensätze einzufügen. Da die Tabelle zuvor aber entfernt wurde, schlägt dies fehl.

\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> imp scott/tiger

Import: Release 11.2.0.1.0 - Production on Fri Jun 21 07:43:07 2013
Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.
Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

Import data only (yes/no): no > 
Import file: expdat.dmp > dbarc02.dmp
Enter insert buffer size (minimum is 8192) 30720> 

Export file created by EXPORT:V11.02.00 via conventional path
import done in US7ASCII character set and AL16UTF16 NCHAR character set
import server uses AL32UTF8 character set (possible charset conversion)

List contents of import file only (yes/no): no > 
Ignore create error due to object existence (yes/no): no > 
Import grants (yes/no): yes > 
Import table data (yes/no): yes > 
Import entire export file (yes/no): no > 
Username: scott
Enter table(T) or partition(T:P) names. Null list means all tables for user
Enter table(T) or partition(T:P) name or . if done: emp
Enter table(T) or partition(T:P) name or . if done: .

. importing SCOTT's objects into SCOTT
. importing SCOTT's objects into SCOTT
. . importing table                          "EMP"         14 rows imported
About to enable constraints...
Import terminated successfully without warnings.
\end{lstlisting}

\subsection{Tabelle prüfen}
Die Tabelle konnte erfolgreich wiederhergestellt werden:

\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> sqlplus scott/tiger

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 07:45:46 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.
Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> DESC emp;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 EMPNO					   NOT NULL NUMBER(4)
 ENAME						    VARCHAR2(10)
 JOB						    VARCHAR2(9)
 MGR						    NUMBER(4)
 HIREDATE					    DATE
 SAL						    NUMBER(7,2)
 COMM						    NUMBER(7,2)
 DEPTNO 					    NUMBER(2)
\end{lstlisting}


\section{Export / Import einer Datenbank}
\subsection{Export der Datenbank}
Den Export der gesamtem Datenkbank haben wir mit dem exp-Befehl durchgeführt. Der Output umfasste ingesamt ca. 1300 Zeilen, daher haben wir hier einiges rausgeschnitten. Wir sehen, dass unter Anderem auch die Tabellen \glqq{}dep\grqq{} und \glqq{}emp\grqq{} des Benuzters scott exportiert wurden.
\lstinputlisting{backup_recovery/exp_db_output_cut.txt}

Wir prüfen auch hier, ob die Export-Files gemäss unseren Vorstellungen erstellt wurden. Der Full-Dump ist um ein Vielfaches grösser als der zuvor erstellte Tabellenexport.
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> ls -lh
total 42M
-rw-r--r-- 1 oracle_stud oinstall  24K 2013-06-21 07:23 dbarc02.dmp
-rw-r--r-- 1 oracle_stud oinstall  41M 2013-06-21 08:25 dbarc02_full.dmp
-rw-r--r-- 1 oracle_stud oinstall  70K 2013-06-21 08:25 dbarc02_full.log
-rw-r--r-- 1 oracle_stud oinstall 1.7K 2013-06-21 07:23 dbarc02.log
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export>
\end{lstlisting}

\subsection{User Scott samt Objekten löschen}
Nach dem Entfernen des Benutzers überprüfen wir mit Hilfe von \emph{all\_users}, ob der Benutzer auch tatsächlich entfernt wurde.
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> sqlplus system/manager

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 08:45:10 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> DROP USER scott CASCADE;
User dropped.

SQL> select * from all_users;

USERNAME			  USER_ID CREATED
------------------------------ ---------- ---------
MGMT_VIEW			       35 08-MAR-13
SYSMAN				       33 08-MAR-13
APPQOSSYS			       31 08-MAR-13
DBSNMP				       30 08-MAR-13
ORACLE_OCM			       21 08-MAR-13
DIP				       14 08-MAR-13
OUTLN					9 08-MAR-13
SYSTEM					5 08-MAR-13
SYS					0 08-MAR-13

9 rows selected.
\end{lstlisting}

\subsection{User Scott wieder erstellen}
Mit den folgenden Statements haben wir den User Scott neu erstellt und geprüft, ob die Erstellung erfolgreich war:
\begin{lstlisting}
SQL> CREATE USER scott IDENTIFIED BY tiger
  2  DEFAULT TABLESPACE users
  3  QUOTA UNLIMITED ON users;
User created.

SQL> GRANT CONNECT TO scott;
Grant succeeded.

SQL> ALTER USER scott DEFAULT ROLE all;
User altered.

SQL> select * from all_users;
USERNAME			  USER_ID CREATED
------------------------------ ---------- ---------
MGMT_VIEW			       35 08-MAR-13
SYSMAN				       33 08-MAR-13
SCOTT				       36 21-JUN-13
APPQOSSYS			       31 08-MAR-13
DBSNMP				       30 08-MAR-13
ORACLE_OCM			       21 08-MAR-13
DIP				       14 08-MAR-13
OUTLN					9 08-MAR-13
SYSTEM					5 08-MAR-13
SYS					0 08-MAR-13
10 rows selected.
\end{lstlisting}

\subsection{Daten importieren}
Die in folgendem Listing enthaltenen Fehlermeldungen resp. Warnungen (bzgl. dem System-Tablespace) zeigen, dass die Erstellung des Benutzers zuvor noch nicht korrekt war. Mit diesen Warnungen werden zwar die Tabellen erstellt, allerdings fehlen danach die Datensätze.

\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> imp system/manager file=${ORACLE_SID}_full fromuser=scott touser=scott

Import: Release 11.2.0.1.0 - Production on Fri Jun 21 09:17:32 2013

Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.


Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

Export file created by EXPORT:V11.02.00 via conventional path
import done in US7ASCII character set and AL16UTF16 NCHAR character set
import server uses AL32UTF8 character set (possible charset conversion)
. importing SCOTT's objects into SCOTT
. . importing table                         "DEPT"
IMP-00058: ORACLE error 1950 encountered
ORA-01950: no privileges on tablespace 'SYSTEM'
. . importing table                          "EMP"
IMP-00058: ORACLE error 1950 encountered
ORA-01950: no privileges on tablespace 'SYSTEM'
. . importing table                     "SALGRADE"
IMP-00058: ORACLE error 1950 encountered
ORA-01950: no privileges on tablespace 'SYSTEM'
About to enable constraints...
Import terminated successfully with warnings
\end{lstlisting}

Eine Analyse des Problems und des Dump-Files (einfaches anschauen mittels \emph{less}) ergab, dass die Tabellen \emph{dept} und \emph{emp} vor dem Export nicht im Users-Tablespace, sondern im System-Tablespace lagen. Da es ohne Umwege mit dem Utility \emph{imp} nicht möglich ist, die Tabellen des Benutzers in einen anderen Tablespace zu importieren, haben wir dem User Scott ebenfalls Platz auf dem System-Tablespace gegeben:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> sqlplus system/manager

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 10:04:14 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> ALTER USER scott QUOTA UNLIMITED ON system;

User altered.
\end{lstlisting}

Diese Anpassung haben wir nach einem erneuten Entfernen und Neu-Erstellung des Benutzers scott vorgenommen. Der Import läuft nun ordnungsgemäss durch:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> imp system/manager file=${ORACLE_SID}_full fromuser=scott touser=scott

Import: Release 11.2.0.1.0 - Production on Fri Jun 21 10:13:12 2013

Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.


Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

Export file created by EXPORT:V11.02.00 via conventional path
import done in US7ASCII character set and AL16UTF16 NCHAR character set
import server uses AL32UTF8 character set (possible charset conversion)
. importing SCOTT's objects into SCOTT
. . importing table                         "DEPT"          4 rows imported
. . importing table                          "EMP"         14 rows imported
. . importing table                     "SALGRADE"          5 rows imported
About to enable constraints...
Import terminated successfully without warnings.
\end{lstlisting}

\subsection{User Scott testen}
Nach dem Zurückladen der Daten melden wir uns an und prüfen das Vorhandensein der Tabellen von Scott:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> sqlplus scott/tiger

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 10:15:08 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> desc emp;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 EMPNO					   NOT NULL NUMBER(4)
 ENAME						    VARCHAR2(10)
 JOB						    VARCHAR2(9)
 MGR						    NUMBER(4)
 HIREDATE					    DATE
 SAL						    NUMBER(7,2)
 COMM						    NUMBER(7,2)
 DEPTNO 					    NUMBER(2)

SQL> select * from dept;

    DEPTNO DNAME	  LOC
---------- -------------- -------------
	10 ACCOUNTING	  NEW YORK
	20 RESEARCH	  DALLAS
	30 SALES	  CHICAGO
	40 OPERATIONS	  BOSTON

\end{lstlisting}


\section{Cold Backup}
\subsection{DB Stop}
Wir fahren die DB gemäss Anleitung in der Aufgabenstellung herunter:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> sqlplus /nolog

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 10:20:36 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

SQL> CONNECT / as sysdba
Connected.
SQL> SHUTDOWN IMMEDIATE
Database closed.
Database dismounted.
ORACLE instance shut down.
\end{lstlisting}

Die Kontrolle mittels des ps-Befehls zeigt, dass unsere Instanz (dbarc02) erfolgreich beendet wurde:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/export> ps -ef | grep smon
1001       641     1  0 Jun14 ?        00:00:14 ora_smon_dbarc01
1001      2907     1  0 May30 ?        00:01:34 ora_smon_dbarc04
1001      2957     1  0 Jun18 ?        00:00:06 ora_smon_dbarc07
1001     12380     1  0 May01 ?        00:01:43 ora_smon_dbarc08
oracle   12826     1  0 Mar01 ?        00:05:11 ora_smon_hades11g
1001     14183     1  0 Mar15 ?        00:02:18 ora_smon_dbarc06
1001     20249     1  0 Mar08 ?        00:06:40 ora_smon_mydb
1001     26856 20395  0 10:22 pts/0    00:00:00 grep smon
oracle   29737     1  0 Mar01 ?        00:04:15 ora_smon_ananke
1001     30687     1  0 Jun07 ?        00:00:39 ora_smon_dbarc05
\end{lstlisting}

\subsection{Sicherung}
Die Sicherung besteht nun aus einem einfachen Datei-Kopiervorgang. Da die Datenbank-Instanz zuvor gestoppt wurde, sind die Dateien in einem konsistenten Zustand.

\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> cp -v * ../cold_backup/
`control01.ctl' -> `../cold_backup/control01.ctl'
`control02.ctl' -> `../cold_backup/control02.ctl'
`control03.ctl' -> `../cold_backup/control03.ctl'
`redo01.log' -> `../cold_backup/redo01.log'
`redo02.log' -> `../cold_backup/redo02.log'
`redo03.log' -> `../cold_backup/redo03.log'
`sysaux01.dbf' -> `../cold_backup/sysaux01.dbf'
`system01.dbf' -> `../cold_backup/system01.dbf'
`temp01.dbf' -> `../cold_backup/temp01.dbf'
`undotbs01.dbf' -> `../cold_backup/undotbs01.dbf'
`users01.dbf' -> `../cold_backup/users01.dbf'
\end{lstlisting}

\subsection{Neustart, Test, Modifikation}
Da auf der Tabelle ein Primary-Key definiert ist, funktioniert das angegebene Insert-Statement nicht. Wir haben stattdessen mit dem folgenden Statement eine neue Zeile hinzugefügt und die Anzahl Zeilen geprüft.
\begin{lstlisting}
SQL> INSERT INTO "SCOTT"."EMP" (EMPNO, ENAME, JOB, HIREDATE, SAL, DEPTNO) VALUES ('1337', 'TEST', 'BOSS', TO_DATE('23-JAN-82', 'DD-MON-RR'), '1337', '10')

SQL> select count(*) from emp;                   

  COUNT(*)
----------
	15
\end{lstlisting}

\subsection{Fehler provozieren}
Die Tabelle \emph{emp} liegt im \emph{System}-Tablespace, daher benennen wir dieses File um.

Danach tritt beim angegebenen Statement wie erwartet ein Fehler auf (INSERT INTO und SELECT * FROM funktionierten hingegen noch, da die Informationen wohl noch im Cache vorhanden waren).
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> sqlplus scott/tiger

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 10:49:21 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.
Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> CREATE TABLE aaa AS SELECT * FROM emp;
CREATE TABLE aaa AS SELECT * FROM emp
                                  *
ERROR at line 1:
ORA-00604: error occurred at recursive SQL level 2
ORA-01116: error in opening database file 1
ORA-01110: data file 1: '/app/oracle_stud/oradata/dbarc02/data/system01.dbf'
ORA-27041: unable to open file
Linux-x86_64 Error: 2: No such file or directory
Additional information: 3
\end{lstlisting}

\subsection{Reparatur}
Wir konnten uns aufgrund der folgenden Fehlermeldung nicht mehr normal auf die Instanz verbinden:
\begin{lstlisting}
SQL> CONNECT / AS sysdba
ERROR:
ORA-01075: you are currently logged on
\end{lstlisting}

Informationen von \url{http://bit.ly/btEuNm} haben uns dann allerdings weitergeholfen, so dass wir die Instanz doch noch abwürgen konnten:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> sqlplus -prelim "/as sysdba"

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 11:00:44 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

SQL> SHUTDOWN ABORT;
ORACLE instance shut down.
\end{lstlisting}

Nach dem Stop der Instanz haben wir alle Files unter Beibehaltung der Berechtigungen (Option \emph{-p} von \emph{cp}) aus dem erstellten Cold-Backup zurückkopiert und die Datenbank neu gestartet:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> rm -v * && cp -pv ../cold_backup/* .
removed `control01.ctl'
removed `control02.ctl'
removed `control03.ctl'
removed `redo01.log'
removed `redo02.log'
removed `redo03.log'
removed `sysaux01.dbf'
removed `system01.dbf_'
removed `temp01.dbf'
removed `undotbs01.dbf'
removed `users01.dbf'
`../cold_backup/control01.ctl' -> `./control01.ctl'
`../cold_backup/control02.ctl' -> `./control02.ctl'
`../cold_backup/control03.ctl' -> `./control03.ctl'
`../cold_backup/redo01.log' -> `./redo01.log'
`../cold_backup/redo02.log' -> `./redo02.log'
`../cold_backup/redo03.log' -> `./redo03.log'
`../cold_backup/sysaux01.dbf' -> `./sysaux01.dbf'
`../cold_backup/system01.dbf' -> `./system01.dbf'
`../cold_backup/temp01.dbf' -> `./temp01.dbf'
`../cold_backup/undotbs01.dbf' -> `./undotbs01.dbf'
`../cold_backup/users01.dbf' -> `./users01.dbf'

oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> sqlplus /nolog

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 11:14:46 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

SQL> CONNECT / as sysdba
Connected to an idle instance.
SQL> STARTUP
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size		    2213936 bytes
Variable Size		  339740624 bytes
Database Buffers	   67108864 bytes
Redo Buffers		    8482816 bytes
Database mounted.
Database opened.
\end{lstlisting}

\subsection{Test Benutzer scott}
Wir können uns nun wieder als Scott verbinden und stellen fest, dass die Tabelle im Zustand zum Zeitpunkt des Cold-Backups wieder verfügbar ist.
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> sqlplus scott/tiger

SQL*Plus: Release 11.2.0.1.0 Production on Fri Jun 21 11:16:47 2013
Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> select count(*) from emp;

  COUNT(*)
----------
	14
\end{lstlisting}


\section{Archive Mode}
\subsection{Vorbereitung}
\subsubsection{Archive-Mode aktivieren}
Wir aktivieren den Archive-Mode mit folgenden Befehlen:
\begin{lstlisting}
oracle_stud@hades:~> export ORACLE_SID=dbarc02
oracle_stud@hades:~> sqlplus /nolog

SQL*Plus: Release 11.2.0.1.0 Production on Sun Jun 23 17:34:06 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

SQL> connect / as sysdba
Connected.

SQL> SHUTDOWN immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

SQL> STARTUP MOUNT;
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             339740624 bytes
Database Buffers           67108864 bytes
Redo Buffers                8482816 bytes
Database mounted.

SQL> ALTER database archivelog;

Database altered.

SQL> ALTER database open;

Database altered.
\end{lstlisting}
\subsubsection{Platz schaffen}
Wir wollen zuerst herausfinden, wie viel virtueller Platz noch vorhanden ist. Dazu führen wir im Oracle SQL Developer folgendes Skript aus:
\begin{lstlisting}
SELECT
substr(name, 1, 30) name,
space_limit AS quota,
space_used AS used,
space_reclaimable AS reclaimable,
number_of_files AS files
FROM v$recovery_file_dest ;

NAME                                QUOTA       USED RECLAIMABLE      FILES
------------------------------ ---------- ---------- ----------- ----------
/app/oracle/flash_recovery_are    5.4E+10    4.8E+10     2.5E+10        528 
\end{lstlisting}
Das Resultat zeigt uns nun, dass 4.8G von 5.2G belegt sind.

Wir vergrössern nun den verfügbaren Platz mit folgendem Befehl:
\begin{lstlisting}
SQL> alter system set db_recovery_file_dest_size=10G;

System altered.
\end{lstlisting}

\subsubsection{Situation anzeigen}
Wir zeigen die aktuelle Situation an und sehen, dass der Archive Mode aktiviert ist:
\begin{lstlisting}
SQL> ARCHIVE LOG LIST;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /app/oracle_stud/oradata/dbarc02/archive
Oldest online log sequence     251
Next log sequence to archive   253
Current log sequence           253
\end{lstlisting}

\subsubsection{Cold-Backup erstellen}
Wir erstellen nun ein Cold-Backup:
\begin{lstlisting}
// Shutdown SQL Instance
SQL> CONNECT / as sysdba
Connected.
SQL> SHUTDOWN immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

// Dateien sichern durch Kopieren
oracle_stud@hades:~> cd /app/oracle_stud/oradata/dbarc02/data
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> cp * ../cold_backup/

//System entlasten, alte Dateien loeschen
oracle_stud@hades:~>cd /app/oracle_stud/oradata/dbarc02/archive
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/archive>find . * -mtime +1 -exec rm {} \;

//Startup SQL Instance
oracle_stud@hades:~> sqlplus / as sysdba

SQL*Plus: Release 11.2.0.1.0 Production on Sun Jun 23 17:59:42 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> STARTUP
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             339740624 bytes
Database Buffers           67108864 bytes
Redo Buffers                8482816 bytes
Database mounted.
Database opened.
\end{lstlisting}

\subsection{Versuch 1}
\subsubsection{Connect als Scott}
Wir verbinden uns als User Scott:
\begin{lstlisting}
SQL> CONNECT scott/tiger
Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM
Connected.
\end{lstlisting}

\subsubsection{Tabelle emp anpassen}
Nun verändern wir die Tabelle emp und stellen sicher, dass 112 Datensätze vorhanden  sind:
\begin{lstlisting}
SQL> INSERT INTO emp SELECT * FROM emp;
INSERT INTO emp SELECT * FROM emp
*
ERROR at line 1:
ORA-00001: unique constraint (SCOTT.PK_EMP) violated
\end{lstlisting}

Da ein Unique Key vorhande ist, müssen wir das Skript ein wenig anpassen, um weitere Daten hinzuzufügen:
\begin{lstlisting}
SQL> insert into emp SELECT (empno/2),ename,job,mgr,hiredate,sal,comm,deptno FROM emp;

14 rows created.

SQL> insert into emp SELECT (empno-100),ename,job,mgr,hiredate,sal,comm,deptno FROM emp;

28 rows created.

SQL> insert into emp SELECT (empno-1000),ename,job,mgr,hiredate,sal,comm,deptno FROM emp;

56 rows created.

SQL> commit;

Commit complete.
\end{lstlisting}

Wir fügen nun Daten ein, bis wir 112 Datensätze haben.
\begin{lstlisting}
SQL> select count (*) from emp;

  COUNT(*)
----------
       112
\end{lstlisting}

\subsubsection{Tabelle viewing erstellen}
Die Tabelle Viewing ist nicht vorhanden, weshalb wir diese nun erstellen:
\begin{lstlisting}
SQL> DESC viewing;
ERROR:
ORA-04043: object viewing does not exist

SQL> CREATE TABLE viewing as SELECT * FROM emp;

Table created.

SQL> select count(*) from viewing;

  COUNT(*)
----------
       112
\end{lstlisting}

\subsubsection{Zeitpunkt A}
Wir halten nun den Zeitpunkt A fest:
\begin{lstlisting}
SELECT TO_CHAR( SYSDATE, 'yyyy-MM-dd:HH24:MI:SS')
FROM dual;

TO_CHAR(SYSDATE,'YYYY-MM-DD:HH24:MI:SS')
----------------------------------------
2013-06-23:18:28:52                      
\end{lstlisting}

\subsubsection{Tabelle dept anpassen}
Auch hier ist der Primary Key ein Problem, weshalb wir wiederum das Skript ein wenig anpassen:
\begin{lstlisting}
SQL> INSERT INTO dept SELECT * FROM dept;
INSERT INTO dept SELECT * FROM dept
*
ERROR at line 1:
ORA-00001: unique constraint (SCOTT.PK_DEPT) violated

SQL> INSERT INTO dept SELECT (deptno+1),dname,loc FROM dept;

4 rows created.

SQL> INSERT INTO dept SELECT (deptno+2),dname,loc FROM dept;

8 rows created.

SQL> INSERT INTO dept SELECT (deptno+4),dname,loc FROM dept;

16 rows created.

SQL> select count(*) from dept;

  COUNT(*)
----------
        32
\end{lstlisting}

\subsubsection{Zeitpunkt B}
Wir halten nun den Zeitpunkt B fest:
\begin{lstlisting}
SELECT TO_CHAR( SYSDATE, 'yyyy-MM-dd:HH24:MI:SS')
FROM dual;

TO_CHAR(SYSDATE,'YYYY-MM-DD:HH24:MI:SS')
----------------------------------------
2013-06-23:18:41:09  
\end{lstlisting}

\subsubsection{Tabelle viewing löschen}
\begin{lstlisting}
SQL> DROP TABLE viewing;

Table dropped.

SQL> commit;

Commit complete.
\end{lstlisting}

\subsubsection{Zeitpunkt C}
Wir halten nun den Zeitpunkt C fest:
\begin{lstlisting}
SELECT TO_CHAR( SYSDATE, 'yyyy-MM-dd:HH24:MI:SS')
FROM dual;

TO_CHAR(SYSDATE,'YYYY-MM-DD:HH24:MI:SS')
----------------------------------------
2013-06-23:18:42:47     
\end{lstlisting}

\subsubsection{Reparatur}
Wir wollen die Datenbank reparieren. Dies machen wir, indem wir die Instanz herunterfahren, die *.dbf Dateien des Cold-Backups zurückholen und die Instanz wieder starten. Anschliessend fahren wir mit den Archive-Logs auf den Zeitpunkt B und prüfen die Situation.

\begin{lstlisting}
//Shutdown Instance
SQL> CONNECT / as sysdba
Connected.
SQL> SHUTDOWN IMMEDIATE
Database closed.
Database dismounted.
ORACLE instance shut down.

//Restore .dbf Files
oracle_stud@hades:~> cd /app/oracle_stud/oradata/dbarc02/cold_backup
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/cold_backup> cp -R *.dbf ../data

//Zustand wiederherstellen
SQL> STARTUP MOUNT
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.

SQL> ALTER DATABASE RECOVER DATABASE
  2  UNTIL TIME '2013-06-23:18:41:09';

Database altered.

//Logs zuruecksetzen
SQL> ALTER DATABASE OPEN RESETLOGS;

Database altered.

//Situation pruefen
SQL> CONNECT scott/tiger
Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM
Connected.
SQL> SELECT COUNT(*) FROM emp;

  COUNT(*)
----------
       112

SQL> SELECT COUNT(*) FROM dept;

  COUNT(*)
----------
        32

SQL> desc viewing;
 Name        Null?    Type
 ----------------------------------------- -------- ---------------------------
 EMPNO          NUMBER(4)
 ENAME          VARCHAR2(10)
 JOB          VARCHAR2(9)
 MGR          NUMBER(4)
 HIREDATE         DATE
 SAL          NUMBER(7,2)
 COMM          NUMBER(7,2)
 DEPTNO          NUMBER(2)
\end{lstlisting}

\subsection{Versuch 2}
\subsubsection{Cold-Backup Restore}
Wir stellen den Zustand vor dem Versuch 1 wieder her:
\begin{lstlisting}
//Shutdown Instance
SQL> CONNECT / as sysdba
Connected.
SQL> SHUTDOWN IMMEDIATE
Database closed.
Database dismounted.
ORACLE instance shut down.

//Restore .dbf Files
oracle_stud@hades:~> cd /app/oracle_stud/oradata/dbarc02/cold_backup
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/cold_backup> cp -R * ../data

//Startup
SQL> startup
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.
Database opened.

//Check
SQL> select count(*) from scott.emp;

  COUNT(*)
----------
        14
\end{lstlisting}

\subsubsection{Connect als Scott}
\begin{lstlisting}
SQL> connect scott/tiger
Error accessing PRODUCT_USER_PROFILE
Warning:  Product user profile information not loaded!
You may need to run PUPBLD.SQL as SYSTEM
Connected.
\end{lstlisting}

\subsubsection{Tabelle emp vergrössern}
Da wir einen Primary Key auf emp haben, müssen wir das Skript anpassen:
\begin{lstlisting}
// Run as Scott
BEGIN
  FOR i IN REVERSE 1..1000 
  LOOP
   INSERT INTO emp (empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES ((select (min(empno)-1) from emp),'blubb','blubb',7566,'08-SEP-81',1,0,10);
  END LOOP;
END;
/

// Run as Scott
COMMIT;
SELECT COUNT(*) FROM emp;
SELECT COUNT(*) FROM dept;
SELECT TO_CHAR( SYSDATE, 'yyyy-MM-dd:HH24:MI:SS')
FROM dual;

// Run as sysdba
ALTER SYSTEM SWITCH LOGFILE;
\end{lstlisting}

Dieses führen wir 10 mal aus, um 10 Archiv-Dateien zu erstellen.

\subsubsection{Tabelle dept vergrössern}
Auch bei der Tabelle dept musssten wir das Sktipt anpassen:
\begin{lstlisting}
// Run as Scott
BEGIN
  FOR i IN REVERSE 1..50 LOOP
   INSERT INTO dept (deptno,dname,loc)
   VALUES ((select (min(deptno)-1) from dept),'Dev','Aarau');
  END LOOP;
END;
/

// Run as Scott
COMMIT;
SELECT COUNT(*) FROM emp;
SELECT COUNT(*) FROM dept;
SELECT TO_CHAR( SYSDATE, 'yyyy-MM-dd:HH24:MI:SS')
FROM dual;

// Run as sysdba
ALTER SYSTEM SWITCH LOGFILE;
\end{lstlisting}

Dieses führen wir 2 mal aus, um 2 weitere Archiv-Dateien zu erstellen.

\subsubsection{Übersicht Archive-Files}
Wir notieren nun die erstellten Archive-Dateien, sowie die aktuelle Situation.

\begin{center}
    \begin{tabular}{| l | l | l | l | l |}
    \hline
	Nr. & Zeitpunkt & Count emp & Count dept & Archive-File abgeschlossen \\ \hline
	D1 & 2013-06-24:19:17:34 & 1014 & 4 & 1\_253\_809526722.dbf \\ \hline
	D2 & 2013-06-24:19:25:18 & 2014 & 4 & 1\_254\_809526722.dbf \\ \hline
	D3 & 2013-06-24:19:28:30 & 3014 & 4 & 1\_255\_809526722.dbf \\ \hline
	D4 & 2013-06-24:19:30:21 & 4014 & 4 & 1\_256\_809526722.dbf \\ \hline
	D5 & 2013-06-24:19:31:13 & 5014 & 4 & 1\_257\_809526722.dbf \\ \hline
	D6 & 2013-06-24:19:32:00 & 6014 & 4 & 1\_258\_809526722.dbf \\ \hline
	D7 & 2013-06-24:19:32:42 & 7014 & 4 & 1\_259\_809526722.dbf \\ \hline
	D8 & 2013-06-24:19:33:40 & 8014 & 4 & 1\_260\_809526722.dbf \\ \hline
	D9 & 2013-06-24:19:34:33 & 9014 & 4 & 1\_261\_809526722.dbf \\ \hline
	D10 & 2013-06-24:19:36:21 & 10014 & 4 & 1\_262\_809526722.dbf \\ \hline
	D11 & 2013-06-24:19:39:50 & 10014 & 54 & 1\_263\_809526722.dbf \\ \hline
	DDD & 2013-06-24:19:46:09 & 10014 & 104 & 1\_264\_809526722.dbf \\ \hline
   \end{tabular}
\end{center}

\subsubsection{Crash simulieren}
Wir haben die Tabellen erweitert und mehrere Archive-Dateien generiert. Nun können wir den Crash simulieren.

\begin{lstlisting}
SQL> connect / as sysdba
Connected.

SQL> SHUTDOWN ABORT;
ORACLE instance shut down.
\end{lstlisting}
\subsubsection{Reparatur}
Wir kopieren die .dbf Files in das data Verzeichnis uns stellen mithilfe der Archive Log Files den Zustand D10 wieder her:
\begin{lstlisting}
//Restore .dbf Files
oracle_stud@hades:~> cd /app/oracle_stud/oradata/dbarc02/cold_backup
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/cold_backup> cp -R *.dbf ../data

//Restore until D10
SQL> STARTUP MOUNT
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.


SQL> RECOVER DATABASE UNTIL TIME '2013-06-24:19:36:21' USING BACKUP CONTROLFILE;
ORA-00279: change 5716560 generated at 06/23/2013 17:53:12 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_253_809526722.dbf
ORA-00280: change 5716560 for thread 1 is in sequence #253


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5744736 generated at 06/24/2013 06:05:11 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_254_809526722.dbf
ORA-00280: change 5744736 for thread 1 is in sequence #254
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_253_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5776405 generated at 06/24/2013 19:22:06 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_255_809526722.dbf
ORA-00280: change 5776405 for thread 1 is in sequence #255
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_254_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5777546 generated at 06/24/2013 19:25:29 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_256_809526722.dbf
ORA-00280: change 5777546 for thread 1 is in sequence #256
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_255_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5778733 generated at 06/24/2013 19:28:50 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_257_809526722.dbf
ORA-00280: change 5778733 for thread 1 is in sequence #257
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_256_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5779827 generated at 06/24/2013 19:30:53 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_258_809526722.dbf
ORA-00280: change 5779827 for thread 1 is in sequence #258
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_257_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5780880 generated at 06/24/2013 19:31:36 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_259_809526722.dbf
ORA-00280: change 5780880 for thread 1 is in sequence #259
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_258_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5781938 generated at 06/24/2013 19:32:24 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_260_809526722.dbf
ORA-00280: change 5781938 for thread 1 is in sequence #260
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_259_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5782997 generated at 06/24/2013 19:33:09 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_261_809526722.dbf
ORA-00280: change 5782997 for thread 1 is in sequence #261
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_260_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5784059 generated at 06/24/2013 19:34:09 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_262_809526722.dbf
ORA-00280: change 5784059 for thread 1 is in sequence #262
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_261_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

ORA-00279: change 5785121 generated at 06/24/2013 19:34:57 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_263_809526722.dbf
ORA-00280: change 5785121 for thread 1 is in sequence #263
ORA-00278: log file
'/app/oracle_stud/oradata/dbarc02/archive/1_262_809526722.dbf' no longer needed
for this recovery


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}
CANCEL
Media recovery cancelled.
\end{lstlisting}

Nun überprüfen wir, ob der richtige Zeitpunkt gewählt wurde, um den Restore abzubrechen.

\begin{lstlisting}
SQL> ALTER DATABASE OPEN READ ONLY;

Database altered.

SQL> select count(*) from scott.emp;

  COUNT(*)
----------
      9014

SQL> select count(*) from scott.dept;

  COUNT(*)
----------
         4
\end{lstlisting}

Wir wollen den Zustand unmittelbar vor dem vergrössern der dept Tabelle widerherstellen. Dazu müssen wir also noch ein weiteres Archive-Log wiederherstellen:
\begin{lstlisting}
SQL> SHUTDOWN
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> STARTUP MOUNT
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.
SQL> RECOVER DATABASE UNTIL TIME '2013-06-24:19:36:21' USING BACKUP CONTROLFILE;
ORA-00279: change 5785121 generated at 06/24/2013 19:34:57 needed for thread 1
ORA-00289: suggestion :
/app/oracle_stud/oradata/dbarc02/archive/1_263_809526722.dbf
ORA-00280: change 5785121 for thread 1 is in sequence #263


Specify log: {<RET>=suggested | filename | AUTO | CANCEL}

Log applied.
Media recovery complete.
\end{lstlisting}

Wir überprüfen nun wiederum die Situation, diese sollte dem Zustand vor dem Vergrössern der dept Tabelle entsprechen:

\begin{lstlisting}
SQL> select count(*) from scott.emp;

  COUNT(*)
----------
     10014

SQL> select count(*) from scott.dept;

  COUNT(*)
----------
         4
\end{lstlisting}

Alternativ zu der von uns gewählten Methode der Wiederherstellung, kann einfach mit 'RECOVER DATABASE UNTIL CANCEL USING BACKUP CONTROLFILE' die Wiederherstellung gestartet werden, wenn man den Zeitpunkt nicht genau weiss. Dabei muss immer wieder überprüft werden, ob der gwünschte Zustand bereits erreicht ist oder nicht.

Bei der von uns gewählten Methode mit 'UNTIL TIME ..' kann mit 'AUTO' direkt bis zum vorgeschlagenen Zeitpunkt wiederhergestellt werden.

Da wir nun den gewünschten Zustand wiederhergestellt haben, können wir die weiteren Archive-Log Files löschen:

\begin{lstlisting}
SQL> ALTER DATABASE OPEN RESETLOGS;

Database altered.
\end{lstlisting}
\subsubsection{System entlasten}
Da wir die beiden Versuche erfolgreich durchgeführt haben, löschen wir alle Archiv-Files und setzen die Datenbank in den noarchivelog Modus zurück. Die beiden Tabellen emp und dept werden ebenfalls gelöscht und neu erzeugt.

\begin{lstlisting}
CONNECT scott/tiger
@/app/oracle_stud/admin/scripts/demobld.sql

connect / as sysdba
SQL> SHUTDOWN
Database closed.
Database dismounted.
STARTUP MOUNT
ORACLE instance shut down.
SQL> ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.
SQL> ALTER DATABASE NOARCHIVELOG;

Database altered.

SQL> ALTER DATABASE OPEN;

Database altered.

SQL> ARCHIVE LOG LIST;
Database log mode              No Archive Mode
Automatic archival             Disabled
Archive destination            /app/oracle_stud/oradata/dbarc02/archive
Oldest online log sequence     1
Current log sequence           1


oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/archive> ls -la
total 76124
drwxr-xr-x 2 oracle_stud oinstall     4096 2013-06-24 20:12 .
drwxr-xr-x 6 oracle_stud oinstall     4096 2013-03-08 10:10 ..
-rw-r----- 1 oracle_stud oinstall 39293440 2013-06-24 06:05 1_253_809526722.dbf
-rw-r----- 1 oracle_stud oinstall 32441344 2013-06-24 19:22 1_254_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   656896 2013-06-24 19:25 1_255_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   728064 2013-06-24 19:28 1_256_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   637952 2013-06-24 19:30 1_257_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   600576 2013-06-24 19:31 1_258_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   619008 2013-06-24 19:32 1_259_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   602624 2013-06-24 19:33 1_260_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   627712 2013-06-24 19:34 1_261_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   628736 2013-06-24 19:34 1_262_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   666112 2013-06-24 19:36 1_263_809526722.dbf
-rw-r----- 1 oracle_stud oinstall   173056 2013-06-24 20:12 1_264_809526722.dbf
-rw-r----- 1 oracle_stud oinstall    97280 2013-06-24 20:12 1_265_809526722.dbf
-rw-r----- 1 oracle_stud oinstall    10752 2013-06-24 20:12 1_266_809526722.dbf
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/archive> rm *.dbf
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/archive> ls -la
total 8
drwxr-xr-x 2 oracle_stud oinstall 4096 2013-06-24 20:27 .
drwxr-xr-x 6 oracle_stud oinstall 4096 2013-03-08 10:10 ..

\end{lstlisting}


\section{Hot Backup}
\subsection{Vorbereitung}
Wir überprüfen, ob die Datenbank im Archive-Modus läuft:
\begin{lstlisting}
SQL> ARCHIVE LOG LIST;
Database log mode              No Archive Mode
Automatic archival             Disabled
Archive destination            /app/oracle_stud/oradata/dbarc02/archive
Oldest online log sequence     1
Current log sequence           1
\end{lstlisting}

Dies ist nicht der Fall, daher müssen wir die Datenbank in der Archive-Modus versetzen mit:
\begin{lstlisting}
SQL> SHUTDOWN immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

SQL>  STARTUP MOUNT;
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.

SQL> ALTER database archivelog;

Database altered.

SQL> ALTER database open;

Database altered.
\end{lstlisting}

Zudem erstellen wir das Verzeichnis hot\_backup, in welches später unsere Backups gespeichert werden:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02> mkdir hot_backup
\end{lstlisting}
\subsection{Arbeiten}
Wir arbeiten als User Scott an der Tabelle emp.

\begin{lstlisting}
SQL> select count(*) from emp;

  COUNT(*)
----------
        14

SQL>  insert into emp SELECT (empno-1000),ename,job,mgr,hiredate,sal,comm,deptno FROM emp;

14 rows created.

SQL> select count(*) from emp;

  COUNT(*)
----------
        28

SQL> commit;

Commit complete.

SQL>  insert into emp SELECT (empno-1000),ename,job,mgr,hiredate,sal,comm,deptno FROM emp;

28 rows created.

SQL> select count(*) from emp;

  COUNT(*)
----------
        56
\end{lstlisting}
\subsection{Backup}
Wir müssen zuerst herausfinden, in welchem Tablespace die Tabelle emp ist. Dazu führen wir folgendes SQL Skript aus:

\begin{lstlisting}
SQL> select t.table_name,t.tablespace_name,df.file_name from dba_tables t, dba_data_files df where t.tablespace_name = df.tablespace_name and table_name like 'EMP';

TABLE_NAME                     TABLESPACE_NAME
------------------------------ ------------------------------
FILE_NAME
--------------------------------------------------------------------------------
EMP                            SYSTEM
/app/oracle_stud/oradata/dbarc02/data/system01.dbf
\end{lstlisting}

Die Tabelle emp ist im Tablespace System. Diesen Tablespace können wir nun für das Backup vorbereiten:

\begin{lstlisting}
SQL> alter tablespace system begin backup;

Tablespace altered.
\end{lstlisting}

Nun können wir ein hot\_backup des System Tablespaces ziehen:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02> cd /app/oracle_stud/oradata/dbarc02/data
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> cp system01.dbf ../hot_backup/

oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/data> ls -la ../hot_backup/
total 363896
drwxr-xr-x 2 oracle_stud oinstall      4096 2013-06-24 21:00 .
drwxr-xr-x 7 oracle_stud oinstall      4096 2013-06-24 20:41 ..
-rw-r----- 1 oracle_stud oinstall 372252672 2013-06-24 21:00 system01.dbf
\end{lstlisting}

Nun können wir den Tablespace wieder in den normalen Modus versetzen:

\begin{lstlisting}
SQL> alter tablespace system end backup;

Tablespace altered.
\end{lstlisting}

Wir können nun noch einmal Daten ändern:

\begin{lstlisting}
SQL>  insert into emp SELECT (empno-1000),ename,job,mgr,hiredate,sal,comm,deptno FROM emp;

56 rows created.

SQL> select count(*) from emp;

  COUNT(*)
----------
       112
\end{lstlisting}

\subsection{Crash}
Wir simulieren nun einen Crash.

\begin{lstlisting}
SQL> connect / as sysdba
Connected.

SQL> SHUTDOWN ABORT;
ORACLE instance shut down.
\end{lstlisting}

\subsection{Reparatur}
Wir wollen nach dem Crash das Backup wiederherstellen. Dazu kopieren wir das hot\_backup in den data Ordner und führen anschliessend das Revocery durch:
\begin{lstlisting}
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02> cd /app/oracle_stud/oradata/dbarc02/hot_backup
oracle_stud@hades:/app/oracle_stud/oradata/dbarc02/hot_backup> cp system01.dbf ../data/

// Als sysdba
SQL> STARTUP MOUNT
ORACLE instance started.

Total System Global Area  417546240 bytes
Fixed Size                  2213936 bytes
Variable Size             343934928 bytes
Database Buffers           62914560 bytes
Redo Buffers                8482816 bytes
Database mounted.

SQL> RECOVER DATABASE;
Media recovery complete.

SQL> ALTER DATABASE OPEN;

Database altered.
\end{lstlisting}
\subsection{Überprüfung}
Zum Schluss prüfen wir die aktuelle Situation:

\begin{lstlisting}
SQL> select count(*) from emp;

  COUNT(*)
----------
        28
\end{lstlisting}

Wir sehen, dass nur die Daten vorhanden sind, welche vor dem Backup auch commited wurden. Dies ist korrekt.
\section{Reflexion}
oh noez, schwarz?

jap


\end{document}